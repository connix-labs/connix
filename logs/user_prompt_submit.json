[
  {
    "session_id": "97fa1bbf-c85d-406a-8109-267246420e69",
    "transcript_path": "/home/connerohnesorge/.claude/projects/-home-connerohnesorge-Documents-002Orgs-connix-api-conn/97fa1bbf-c85d-406a-8109-267246420e69.jsonl",
    "cwd": "/home/connerohnesorge/Documents/002Orgs/connix/api/conn",
    "hook_event_name": "UserPromptSubmit",
    "prompt": "implement a conn mcp command with modern organization !: ---\ntitle: \"mark3labs/mcp-go: A Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools.\"\nsource: \"https://github.com/mark3labs/mcp-go\"\nauthor:\n  - \"[[adityamj]]\"\npublished:\ncreated: 2025-07-19\ndescription: \"A Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools. - mark3labs/mcp-go\"\ntags:\n  - \"clippings\"\n---\n**[mcp-go](https://github.com/mark3labs/mcp-go)** Public\n\nA Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools.\n\n[mcp-go.dev/](http://mcp-go.dev/ \"http://mcp-go.dev/\")\n\n[MIT license](https://github.com/mark3labs/mcp-go/blob/main/LICENSE)\n\n[Code of conduct](https://github.com/mark3labs/mcp-go/blob/main/CODE_OF_CONDUCT.md)\n\n[Security policy](https://github.com/mark3labs/mcp-go/blob/main/SECURITY.md)\n\n[6.5k stars](https://github.com/mark3labs/mcp-go/stargazers) [642 forks](https://github.com/mark3labs/mcp-go/forks) [47 watching](https://github.com/mark3labs/mcp-go/watchers) [Branches](https://github.com/mark3labs/mcp-go/branches) [Tags](https://github.com/mark3labs/mcp-go/tags) [Activity](https://github.com/mark3labs/mcp-go/activity) [Custom properties](https://github.com/mark3labs/mcp-go/custom-properties)\n\nPublic repository\n\n[Open in github.dev](https://github.dev/) [Open in a new github.dev tab](https://github.dev/) [Open in codespace](https://github.com/codespaces/new/mark3labs/mcp-go?resume=1)\n\n<table><thead><tr><th colspan=\"2\"><span>Name</span></th><th colspan=\"1\"><span>Name</span></th><th><p><span>Last commit message</span></p></th><th colspan=\"1\"><p><span>Last commit date</span></p></th></tr></thead><tbody><tr><td colspan=\"3\"></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/.github\">.github</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/.github\">.github</a></p></td><td><p><a href=\"https://github.com/mark3labs/mcp-go/commit/f1015695362a5842a1bd9e4a86770f2b0d59ef56\">Docs (</a><a href=\"https://github.com/mark3labs/mcp-go/pull/325\">#325</a><a href=\"https://github.com/mark3labs/mcp-go/commit/f1015695362a5842a1bd9e4a86770f2b0d59ef56\">)</a></p></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/client\">client</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/client\">client</a></p></td><td></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/examples\">examples</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/examples\">examples</a></p></td><td><p><a href=\"https://github.com/mark3labs/mcp-go/commit/e859847efc844f904dac49f8220cb5c911ffed91\">feat: support in tool result handling &amp; update example (</a><a href=\"https://github.com/mark3labs/mcp-go/pull/467\">#467</a><a href=\"https://github.com/mark3labs/mcp-go/commit/e859847efc844f904dac49f8220cb5c911ffed91\">)</a></p></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/mcp\">mcp</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/mcp\">mcp</a></p></td><td></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/mcptest\">mcptest</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/mcptest\">mcptest</a></p></td><td><p><a href=\"https://github.com/mark3labs/mcp-go/commit/251da138d6b5ade77bb2155e0aa294843cb16337\">feature: add support ResourceTemplates to mcptest package (</a><a href=\"https://github.com/mark3labs/mcp-go/pull/449\">#449</a><a href=\"https://github.com/mark3labs/mcp-go/commit/251da138d6b5ade77bb2155e0aa294843cb16337\">)</a></p></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/server\">server</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/server\">server</a></p></td><td></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/testdata\">testdata</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/testdata\">testdata</a></p></td><td><p><a href=\"https://github.com/mark3labs/mcp-go/commit/09c23b5fec768432e3362bea05e69f57a3bc7c92\">fix: type mismatch for request/response ID (</a><a href=\"https://github.com/mark3labs/mcp-go/pull/291\">#291</a><a href=\"https://github.com/mark3labs/mcp-go/commit/09c23b5fec768432e3362bea05e69f57a3bc7c92\">)</a></p></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/util\">util</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/util\">util</a></p></td><td><p><a href=\"https://github.com/mark3labs/mcp-go/commit/2084a3888670487055ef6b5b90b1d3ee10c5b9e7\">Feat: Impl Server-Side Streamable HTTP transport (</a><a href=\"https://github.com/mark3labs/mcp-go/pull/273\">#273</a><a href=\"https://github.com/mark3labs/mcp-go/commit/2084a3888670487055ef6b5b90b1d3ee10c5b9e7\">)</a></p></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/www\">www</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/tree/main/www\">www</a></p></td><td></td><td></td></tr><tr><td colspan=\"2\"><p><a href=\"https://github.com/mark3labs/mcp-go/blob/main/.gitignore\">.gitignore</a></p></td><td colspan=\"1\"><p><a href=\"https://github.com/mark3labs/mcp-go/blob/main/.gitignore\">.gitignore</a></p></td><td><p><a href=\"https://github.com/mark3labs/mcp-go/commit/b7ab1cfc4d1627e1f8e739f3293662a073eb0be0\">Manage tools on a per session basis (</a><a href=\"https://github.com/mark3labs/mcp-go/pull/179\">#179</a><a href=\"https://github.com/mark3labs/mcp-go/commit/b7ab1cfc4d1627e1f8e739f3293662a073eb0be0\">)</a></p></td><td></td></tr><tr><td colspan=\"3\"></td></tr></tbody></table>\n\n[![MCP Go Logo](https://github.com/mark3labs/mcp-go/raw/main/logo.png)](https://github.com/mark3labs/mcp-go/blob/main/logo.png)\n\n**A Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools.**\n\n  \n\n[![Tutorial](https://camo.githubusercontent.com/1e1a0ba616b76aaaea440772a0b1a1254fffe35203feb17fae3df41a1bad32d9/687474703a2f2f696d672e796f75747562652e636f6d2f76692f716f6165594d72584a48302f302e6a7067)](http://www.youtube.com/watch?v=qoaeYMrXJH0 \"Tutorial\")\n\n  \n\nDiscuss the SDK on [Discord](https://discord.gg/RqSS2NQVsY)\n\n```\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/mark3labs/mcp-go/mcp\"\n    \"github.com/mark3labs/mcp-go/server\"\n)\n\nfunc main() {\n    // Create a new MCP server\n    s := server.NewMCPServer(\n        \"Demo \ud83d\ude80\",\n        \"1.0.0\",\n        server.WithToolCapabilities(false),\n    )\n\n    // Add tool\n    tool := mcp.NewTool(\"hello_world\",\n        mcp.WithDescription(\"Say hello to someone\"),\n        mcp.WithString(\"name\",\n            mcp.Required(),\n            mcp.Description(\"Name of the person to greet\"),\n        ),\n    )\n\n    // Add tool handler\n    s.AddTool(tool, helloHandler)\n\n    // Start the stdio server\n    if err := server.ServeStdio(s); err != nil {\n        fmt.Printf(\"Server error: %v\\n\", err)\n    }\n}\n\nfunc helloHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n    name, err := request.RequireString(\"name\")\n    if err != nil {\n        return mcp.NewToolResultError(err.Error()), nil\n    }\n\n    return mcp.NewToolResultText(fmt.Sprintf(\"Hello, %s!\", name)), nil\n}\n```\n\nThat's it!\n\nMCP Go handles all the complex protocol details and server management, so you can focus on building great tools. It aims to be high-level and easy to use.\n\n### Key features:\n\n- **Fast**: High-level interface means less code and faster development\n- **Simple**: Build MCP servers with minimal boilerplate\n- **Complete** \\*: MCP Go aims to provide a full implementation of the core MCP specification\n\n(\\*emphasis on *aims*)\n\n\ud83d\udea8 \ud83d\udea7 \ud83c\udfd7\ufe0f *MCP Go is under active development, as is the MCP specification itself. Core features are working but some advanced capabilities are still in progress.*\n\n- [Installation](https://github.com/mark3labs/#installation)\n- [Quickstart](https://github.com/mark3labs/#quickstart)\n- [What is MCP?](https://github.com/mark3labs/#what-is-mcp)\n- [Core Concepts](https://github.com/mark3labs/#core-concepts)\n    - [Server](https://github.com/mark3labs/#server)\n    - [Resources](https://github.com/mark3labs/#resources)\n    - [Tools](https://github.com/mark3labs/#tools)\n    - [Prompts](https://github.com/mark3labs/#prompts)\n- [Examples](https://github.com/mark3labs/#examples)\n- [Extras](https://github.com/mark3labs/#extras)\n    - [Transports](https://github.com/mark3labs/#transports)\n    - [Session Management](https://github.com/mark3labs/#session-management)\n        - [Basic Session Handling](https://github.com/mark3labs/#basic-session-handling)\n        - [Per-Session Tools](https://github.com/mark3labs/#per-session-tools)\n        - [Tool Filtering](https://github.com/mark3labs/#tool-filtering)\n        - [Working with Context](https://github.com/mark3labs/#working-with-context)\n    - [Request Hooks](https://github.com/mark3labs/#request-hooks)\n    - [Tool Handler Middleware](https://github.com/mark3labs/#tool-handler-middleware)\n    - [Regenerating Server Code](https://github.com/mark3labs/#regenerating-server-code)\n\n## Installation\n\n```\ngo get github.com/mark3labs/mcp-go\n```\n\n## Quickstart\n\nLet's create a simple MCP server that exposes a calculator tool and some data:\n\n```\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/mark3labs/mcp-go/mcp\"\n    \"github.com/mark3labs/mcp-go/server\"\n)\n\nfunc main() {\n    // Create a new MCP server\n    s := server.NewMCPServer(\n        \"Calculator Demo\",\n        \"1.0.0\",\n        server.WithToolCapabilities(false),\n        server.WithRecovery(),\n    )\n\n    // Add a calculator tool\n    calculatorTool := mcp.NewTool(\"calculate\",\n        mcp.WithDescription(\"Perform basic arithmetic operations\"),\n        mcp.WithString(\"operation\",\n            mcp.Required(),\n            mcp.Description(\"The operation to perform (add, subtract, multiply, divide)\"),\n            mcp.Enum(\"add\", \"subtract\", \"multiply\", \"divide\"),\n        ),\n        mcp.WithNumber(\"x\",\n            mcp.Required(),\n            mcp.Description(\"First number\"),\n        ),\n        mcp.WithNumber(\"y\",\n            mcp.Required(),\n            mcp.Description(\"Second number\"),\n        ),\n    )\n\n    // Add the calculator handler\n    s.AddTool(calculatorTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n        // Using helper functions for type-safe argument access\n        op, err := request.RequireString(\"operation\")\n        if err != nil {\n            return mcp.NewToolResultError(err.Error()), nil\n        }\n        \n        x, err := request.RequireFloat(\"x\")\n        if err != nil {\n            return mcp.NewToolResultError(err.Error()), nil\n        }\n        \n        y, err := request.RequireFloat(\"y\")\n        if err != nil {\n            return mcp.NewToolResultError(err.Error()), nil\n        }\n\n        var result float64\n        switch op {\n        case \"add\":\n            result = x + y\n        case \"subtract\":\n            result = x - y\n        case \"multiply\":\n            result = x * y\n        case \"divide\":\n            if y == 0 {\n                return mcp.NewToolResultError(\"cannot divide by zero\"), nil\n            }\n            result = x / y\n        }\n\n        return mcp.NewToolResultText(fmt.Sprintf(\"%.2f\", result)), nil\n    })\n\n    // Start the server\n    if err := server.ServeStdio(s); err != nil {\n        fmt.Printf(\"Server error: %v\\n\", err)\n    }\n}\n```\n\nThe [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) lets you build servers that expose data and functionality to LLM applications in a secure, standardized way. Think of it like a web API, but specifically designed for LLM interactions. MCP servers can:\n\n- Expose data through **Resources** (think of these sort of like GET endpoints; they are used to load information into the LLM's context)\n- Provide functionality through **Tools** (sort of like POST endpoints; they are used to execute code or otherwise produce a side effect)\n- Define interaction patterns through **Prompts** (reusable templates for LLM interactions)\n- And more!\n\n## Core Concepts\n\n### Server\n\nShow Server Examples\n\nThe server is your core interface to the MCP protocol. It handles connection management, protocol compliance, and message routing:\n\n```\n// Create a basic server\ns := server.NewMCPServer(\n    \"My Server\",  // Server name\n    \"1.0.0\",     // Version\n)\n\n// Start the server using stdio\nif err := server.ServeStdio(s); err != nil {\n    log.Fatalf(\"Server error: %v\", err)\n}\n```\n\n### Resources\n\nShow Resource Examples Resources are how you expose data to LLMs. They can be anything - files, API responses, database queries, system information, etc. Resources can be:\n- Static (fixed URI)\n- Dynamic (using URI templates)\n\nHere's a simple example of a static resource:\n\n```\n// Static resource example - exposing a README file\nresource := mcp.NewResource(\n    \"docs://readme\",\n    \"Project README\",\n    mcp.WithResourceDescription(\"The project's README file\"), \n    mcp.WithMIMEType(\"text/markdown\"),\n)\n\n// Add resource with its handler\ns.AddResource(resource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {\n    content, err := os.ReadFile(\"README.md\")\n    if err != nil {\n        return nil, err\n    }\n    \n    return []mcp.ResourceContents{\n        mcp.TextResourceContents{\n            URI:      \"docs://readme\",\n            MIMEType: \"text/markdown\",\n            Text:     string(content),\n        },\n    }, nil\n})\n```\n\nAnd here's an example of a dynamic resource using a template:\n\n```\n// Dynamic resource example - user profiles by ID\ntemplate := mcp.NewResourceTemplate(\n    \"users://{id}/profile\",\n    \"User Profile\",\n    mcp.WithTemplateDescription(\"Returns user profile information\"),\n    mcp.WithTemplateMIMEType(\"application/json\"),\n)\n\n// Add template with its handler\ns.AddResourceTemplate(template, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {\n    // Extract ID from the URI using regex matching\n    // The server automatically matches URIs to templates\n    userID := extractIDFromURI(request.Params.URI)\n    \n    profile, err := getUserProfile(userID)  // Your DB/API call here\n    if err != nil {\n        return nil, err\n    }\n    \n    return []mcp.ResourceContents{\n        mcp.TextResourceContents{\n            URI:      request.Params.URI,\n            MIMEType: \"application/json\",\n            Text:     profile,\n        },\n    }, nil\n})\n```\n\nThe examples are simple but demonstrate the core concepts. Resources can be much more sophisticated - serving multiple contents, integrating with databases or external APIs, etc.\n\n### Tools\n\nShow Tool Examples\n\nTools let LLMs take actions through your server. Unlike resources, tools are expected to perform computation and have side effects. They're similar to POST endpoints in a REST API.\n\nSimple calculation example:\n\n```\ncalculatorTool := mcp.NewTool(\"calculate\",\n    mcp.WithDescription(\"Perform basic arithmetic calculations\"),\n    mcp.WithString(\"operation\",\n        mcp.Required(),\n        mcp.Description(\"The arithmetic operation to perform\"),\n        mcp.Enum(\"add\", \"subtract\", \"multiply\", \"divide\"),\n    ),\n    mcp.WithNumber(\"x\",\n        mcp.Required(),\n        mcp.Description(\"First number\"),\n    ),\n    mcp.WithNumber(\"y\",\n        mcp.Required(),\n        mcp.Description(\"Second number\"),\n    ),\n)\n\ns.AddTool(calculatorTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n    args := request.GetArguments()\n    op := args[\"operation\"].(string)\n    x := args[\"x\"].(float64)\n    y := args[\"y\"].(float64)\n\n    var result float64\n    switch op {\n    case \"add\":\n        result = x + y\n    case \"subtract\":\n        result = x - y\n    case \"multiply\":\n        result = x * y\n    case \"divide\":\n        if y == 0 {\n            return mcp.NewToolResultError(\"cannot divide by zero\"), nil\n        }\n        result = x / y\n    }\n    \n    return mcp.FormatNumberResult(result), nil\n})\n```\n\nHTTP request example:\n\n```\nhttpTool := mcp.NewTool(\"http_request\",\n    mcp.WithDescription(\"Make HTTP requests to external APIs\"),\n    mcp.WithString(\"method\",\n        mcp.Required(),\n        mcp.Description(\"HTTP method to use\"),\n        mcp.Enum(\"GET\", \"POST\", \"PUT\", \"DELETE\"),\n    ),\n    mcp.WithString(\"url\",\n        mcp.Required(),\n        mcp.Description(\"URL to send the request to\"),\n        mcp.Pattern(\"^https?://.*\"),\n    ),\n    mcp.WithString(\"body\",\n        mcp.Description(\"Request body (for POST/PUT)\"),\n    ),\n)\n\ns.AddTool(httpTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n    args := request.GetArguments()\n    method := args[\"method\"].(string)\n    url := args[\"url\"].(string)\n    body := \"\"\n    if b, ok := args[\"body\"].(string); ok {\n        body = b\n    }\n\n    // Create and send request\n    var req *http.Request\n    var err error\n    if body != \"\" {\n        req, err = http.NewRequest(method, url, strings.NewReader(body))\n    } else {\n        req, err = http.NewRequest(method, url, nil)\n    }\n    if err != nil {\n        return mcp.NewToolResultErrorFromErr(\"unable to create request\", err), nil\n    }\n\n    client := &http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return mcp.NewToolResultErrorFromErr(\"unable to execute request\", err), nil\n    }\n    defer resp.Body.Close()\n\n    // Return response\n    respBody, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return mcp.NewToolResultErrorFromErr(\"unable to read request response\", err), nil\n    }\n\n    return mcp.NewToolResultText(fmt.Sprintf(\"Status: %d\\nBody: %s\", resp.StatusCode, string(respBody))), nil\n})\n```\n\nTools can be used for any kind of computation or side effect:\n\n- Database queries\n- File operations\n- External API calls\n- Calculations\n- System operations\n\nEach tool should:\n\n- Have a clear description\n- Validate inputs\n- Handle errors gracefully\n- Return structured responses\n- Use appropriate result types\n\n### Prompts\n\nShow Prompt Examples\n\nPrompts are reusable templates that help LLMs interact with your server effectively. They're like \"best practices\" encoded into your server. Here are some examples:\n\n```\n// Simple greeting prompt\ns.AddPrompt(mcp.NewPrompt(\"greeting\",\n    mcp.WithPromptDescription(\"A friendly greeting prompt\"),\n    mcp.WithArgument(\"name\",\n        mcp.ArgumentDescription(\"Name of the person to greet\"),\n    ),\n), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {\n    name := request.Params.Arguments[\"name\"]\n    if name == \"\" {\n        name = \"friend\"\n    }\n    \n    return mcp.NewGetPromptResult(\n        \"A friendly greeting\",\n        []mcp.PromptMessage{\n            mcp.NewPromptMessage(\n                mcp.RoleAssistant,\n                mcp.NewTextContent(fmt.Sprintf(\"Hello, %s! How can I help you today?\", name)),\n            ),\n        },\n    ), nil\n})\n\n// Code review prompt with embedded resource\ns.AddPrompt(mcp.NewPrompt(\"code_review\",\n    mcp.WithPromptDescription(\"Code review assistance\"),\n    mcp.WithArgument(\"pr_number\",\n        mcp.ArgumentDescription(\"Pull request number to review\"),\n        mcp.RequiredArgument(),\n    ),\n), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {\n    prNumber := request.Params.Arguments[\"pr_number\"]\n    if prNumber == \"\" {\n        return nil, fmt.Errorf(\"pr_number is required\")\n    }\n    \n    return mcp.NewGetPromptResult(\n        \"Code review assistance\",\n        []mcp.PromptMessage{\n            mcp.NewPromptMessage(\n                mcp.RoleUser,\n                mcp.NewTextContent(\"Review the changes and provide constructive feedback.\"),\n            ),\n            mcp.NewPromptMessage(\n                mcp.RoleAssistant,\n                mcp.NewEmbeddedResource(mcp.ResourceContents{\n                    URI: fmt.Sprintf(\"git://pulls/%s/diff\", prNumber),\n                    MIMEType: \"text/x-diff\",\n                }),\n            ),\n        },\n    ), nil\n})\n\n// Database query builder prompt\ns.AddPrompt(mcp.NewPrompt(\"query_builder\",\n    mcp.WithPromptDescription(\"SQL query builder assistance\"),\n    mcp.WithArgument(\"table\",\n        mcp.ArgumentDescription(\"Name of the table to query\"),\n        mcp.RequiredArgument(),\n    ),\n), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {\n    tableName := request.Params.Arguments[\"table\"]\n    if tableName == \"\" {\n        return nil, fmt.Errorf(\"table name is required\")\n    }\n    \n    return mcp.NewGetPromptResult(\n        \"SQL query builder assistance\",\n        []mcp.PromptMessage{\n            mcp.NewPromptMessage(\n                mcp.RoleUser,\n                mcp.NewTextContent(\"Help construct efficient and safe queries for the provided schema.\"),\n            ),\n            mcp.NewPromptMessage(\n                mcp.RoleUser,\n                mcp.NewEmbeddedResource(mcp.ResourceContents{\n                    URI: fmt.Sprintf(\"db://schema/%s\", tableName),\n                    MIMEType: \"application/json\",\n                }),\n            ),\n        },\n    ), nil\n})\n```\n\nPrompts can include:\n\n- System instructions\n- Required arguments\n- Embedded resources\n- Multiple messages\n- Different content types (text, images, etc.)\n- Custom URI schemes\n\n## Examples\n\nFor examples, see the [`examples/`](https://github.com/mark3labs/mcp-go/blob/main/examples) directory.\n\n## Extras\n\n### Transports\n\nMCP-Go supports stdio, SSE and streamable-HTTP transport layers.\n\n### Session Management\n\nMCP-Go provides a robust session management system that allows you to:\n\n- Maintain separate state for each connected client\n- Register and track client sessions\n- Send notifications to specific clients\n- Provide per-session tool customization\nShow Session Management Examples\n```\n// Create a server with session capabilities\ns := server.NewMCPServer(\n    \"Session Demo\",\n    \"1.0.0\",\n    server.WithToolCapabilities(true),\n)\n\n// Implement your own ClientSession\ntype MySession struct {\n    id           string\n    notifChannel chan mcp.JSONRPCNotification\n    isInitialized bool\n    // Add custom fields for your application\n}\n\n// Implement the ClientSession interface\nfunc (s *MySession) SessionID() string {\n    return s.id\n}\n\nfunc (s *MySession) NotificationChannel() chan<- mcp.JSONRPCNotification {\n    return s.notifChannel\n}\n\nfunc (s *MySession) Initialize() {\n    s.isInitialized = true\n}\n\nfunc (s *MySession) Initialized() bool {\n    return s.isInitialized\n}\n\n// Register a session\nsession := &MySession{\n    id:           \"user-123\",\n    notifChannel: make(chan mcp.JSONRPCNotification, 10),\n}\nif err := s.RegisterSession(context.Background(), session); err != nil {\n    log.Printf(\"Failed to register session: %v\", err)\n}\n\n// Send notification to a specific client\nerr := s.SendNotificationToSpecificClient(\n    session.SessionID(),\n    \"notification/update\",\n    map[string]any{\"message\": \"New data available!\"},\n)\nif err != nil {\n    log.Printf(\"Failed to send notification: %v\", err)\n}\n\n// Unregister session when done\ns.UnregisterSession(context.Background(), session.SessionID())\n```\n\n#### Per-Session Tools\n\nFor more advanced use cases, you can implement the `SessionWithTools` interface to support per-session tool customization:\n\n```\n// Implement SessionWithTools interface for per-session tools\ntype MyAdvancedSession struct {\n    MySession  // Embed the basic session\n    sessionTools map[string]server.ServerTool\n}\n\n// Implement additional methods for SessionWithTools\nfunc (s *MyAdvancedSession) GetSessionTools() map[string]server.ServerTool {\n    return s.sessionTools\n}\n\nfunc (s *MyAdvancedSession) SetSessionTools(tools map[string]server.ServerTool) {\n    s.sessionTools = tools\n}\n\n// Create and register a session with tools support\nadvSession := &MyAdvancedSession{\n    MySession: MySession{\n        id:           \"user-456\",\n        notifChannel: make(chan mcp.JSONRPCNotification, 10),\n    },\n    sessionTools: make(map[string]server.ServerTool),\n}\nif err := s.RegisterSession(context.Background(), advSession); err != nil {\n    log.Printf(\"Failed to register session: %v\", err)\n}\n\n// Add session-specific tools\nuserSpecificTool := mcp.NewTool(\n    \"user_data\",\n    mcp.WithDescription(\"Access user-specific data\"),\n)\n// You can use AddSessionTool (similar to AddTool)\nerr := s.AddSessionTool(\n    advSession.SessionID(),\n    userSpecificTool,\n    func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n        // This handler is only available to this specific session\n        return mcp.NewToolResultText(\"User-specific data for \" + advSession.SessionID()), nil\n    },\n)\nif err != nil {\n    log.Printf(\"Failed to add session tool: %v\", err)\n}\n\n// Or use AddSessionTools directly with ServerTool\n/*\nerr := s.AddSessionTools(\n    advSession.SessionID(),\n    server.ServerTool{\n        Tool: userSpecificTool,\n        Handler: func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n            // This handler is only available to this specific session\n            return mcp.NewToolResultText(\"User-specific data for \" + advSession.SessionID()), nil\n        },\n    },\n)\nif err != nil {\n    log.Printf(\"Failed to add session tool: %v\", err)\n}\n*/\n\n// Delete session-specific tools when no longer needed\nerr = s.DeleteSessionTools(advSession.SessionID(), \"user_data\")\nif err != nil {\n    log.Printf(\"Failed to delete session tool: %v\", err)\n}\n```\n\n#### Tool Filtering\n\nYou can also apply filters to control which tools are available to certain sessions:\n\n```\n// Add a tool filter that only shows tools with certain prefixes\ns := server.NewMCPServer(\n    \"Tool Filtering Demo\",\n    \"1.0.0\",\n    server.WithToolCapabilities(true),\n    server.WithToolFilter(func(ctx context.Context, tools []mcp.Tool) []mcp.Tool {\n        // Get session from context\n        session := server.ClientSessionFromContext(ctx)\n        if session == nil {\n            return tools // Return all tools if no session\n        }\n        \n        // Example: filter tools based on session ID prefix\n        if strings.HasPrefix(session.SessionID(), \"admin-\") {\n            // Admin users get all tools\n            return tools\n        } else {\n            // Regular users only get tools with \"public-\" prefix\n            var filteredTools []mcp.Tool\n            for _, tool := range tools {\n                if strings.HasPrefix(tool.Name, \"public-\") {\n                    filteredTools = append(filteredTools, tool)\n                }\n            }\n            return filteredTools\n        }\n    }),\n)\n```\n\nThe session context is automatically passed to tool and resource handlers:\n\n### Request Hooks\n\nHook into the request lifecycle by creating a `Hooks` object with your selection among the possible callbacks. This enables telemetry across all functionality, and observability of various facts, for example the ability to count improperly-formatted requests, or to log the agent identity during initialization.\n\nAdd the `Hooks` to the server at the time of creation using the `server.WithHooks` option.\n\nAdd middleware to tool call handlers using the `server.WithToolHandlerMiddleware` option. Middlewares can be registered on server creation and are applied on every tool call.\n\nA recovery middleware option is available to recover from panics in a tool call and can be added to the server with the `server.WithRecovery` option.\n\nServer hooks and request handlers are generated. Regenerate them by running:\n\n```\ngo generate ./...\n```\n\nYou need `go` installed and the `goimports` tool available. The generator runs `goimports` automatically to format and fix imports.\n\n## Releases 46\n\n[\\+ 45 releases](https://github.com/mark3labs/mcp-go/releases)\n\n## Packages\n\nNo packages published  \n\n## Used by 1.7k\n\n[\\+ 1,663](https://github.com/mark3labs/mcp-go/network/dependents)\n\n## Deployments 64\n\n- [github-pages](https://github.com/mark3labs/mcp-go/deployments/github-pages)\n\n[\\+ 63 deployments](https://github.com/mark3labs/mcp-go/deployments)\n\n## Languages\n\n- [Go 69.9%](https://github.com/mark3labs/mcp-go/search?l=go)\n- [MDX 29.8%](https://github.com/mark3labs/mcp-go/search?l=mdx)\n- Other 0.3%"
  },
  {
    "session_id": "e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc",
    "transcript_path": "/home/connerohnesorge/.claude/projects/-home-connerohnesorge-Documents-002Orgs-connix-api-conn/e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc.jsonl",
    "cwd": "/home/connerohnesorge/Documents/002Orgs/connix/api/conn",
    "hook_event_name": "UserPromptSubmit",
    "prompt": "add a hooks sub command with subcommands for each of the hooks notification.json\n.rw-r--r-- 3.7M connerohnesorge 19 Jul 08:10 post_tool_use.json\n.rw-r--r-- 170k connerohnesorge 19 Jul 08:10 pre_tool_use.json\n.rw-r--r--  33k connerohnesorge 19 Jul 08:11 stop.json\n.rw-r--r--  13k connerohnesorge 19 Jul 07:42 subagent_stop.json\n.rw-r--r--  98k connerohnesorge 19 Jul 08:06 user_prompt_submit.json\nconnerohnesorge api on \ue0a0 main [!?] via \ud83e\udd5f v1.2.13 via \u2744\ufe0f  impure (dev-"
  },
  {
    "session_id": "97fa1bbf-c85d-406a-8109-267246420e69",
    "transcript_path": "/home/connerohnesorge/.claude/projects/-home-connerohnesorge-Documents-002Orgs-connix-api-conn/97fa1bbf-c85d-406a-8109-267246420e69.jsonl",
    "cwd": "/home/connerohnesorge/Documents/002Orgs/connix/api/conn",
    "hook_event_name": "UserPromptSubmit",
    "prompt": "Polish"
  },
  {
    "session_id": "e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc",
    "transcript_path": "/home/connerohnesorge/.claude/projects/-home-connerohnesorge-Documents-002Orgs-connix-api-conn/e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc.jsonl",
    "cwd": "/home/connerohnesorge/Documents/002Orgs/connix/api/conn",
    "hook_event_name": "UserPromptSubmit",
    "prompt": "/initnix "
  },
  {
    "session_id": "e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc",
    "transcript_path": "/home/connerohnesorge/.claude/projects/-home-connerohnesorge-Documents-002Orgs-connix-api-conn/e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc.jsonl",
    "cwd": "/home/connerohnesorge/Documents/002Orgs/connix/api/conn",
    "hook_event_name": "UserPromptSubmit",
    "prompt": "/initnix "
  },
  {
    "session_id": "e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc",
    "transcript_path": "/home/connerohnesorge/.claude/projects/-home-connerohnesorge-Documents-002Orgs-connix-api-conn/e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc.jsonl",
    "cwd": "/home/connerohnesorge/Documents/002Orgs/connix/api/conn",
    "hook_event_name": "UserPromptSubmit",
    "prompt": "/init    "
  },
  {
    "session_id": "e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc",
    "transcript_path": "/home/connerohnesorge/.claude/projects/-home-connerohnesorge-Documents-002Orgs-connix-api-conn/e6692c9e-bd36-46e6-b4dc-67f2b1fe13bc.jsonl",
    "cwd": "/home/connerohnesorge/Documents/002Orgs/connix/api/conn",
    "hook_event_name": "UserPromptSubmit",
    "prompt": "Improve Code Comments"
  }
]